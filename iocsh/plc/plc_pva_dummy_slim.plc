###############################################################################
# Example of pv access fucntions in ecmcPlugin_Utils
# The pvAccess commands can take "long" time, which can disturb the realtime
# thread, and is therefore executed asyn in a separate thread.
#
# Workflow for a "pv_get()" operation: (update automatically from monitor)
#  1: Regsiter PV with pv_reg_asyn() command (returns handle)
#  2: Wait for pv_reg_asyn() to finish (pv_busy(), pv_conencted())
#  3: Get last read value with pv_value().
#  4: Goto 3 (read again)
#
# Workflow for a "pv_put()" operation:
#  1: Regsiter PV with pv_reg_asyn() command (returns handle)
#  2: Wait for pv_reg_asyn() to finish (pv_busy())
#  3: Initiate asyn write command with pv_put_asyn())
#  4: Wait for pv_put_asyn() to finish (pv_busy())
#  5: Goto 3 (write again)
#
###############################################################################

static.AI:=static.AI+1;

var error:=0;

####### READ PV IOC_TEST:AI ###################################################

# Register pv IOC_TEST:AI when ecmc ioc has started
if(ioc_get_started() and static.aiHandle=0) {
  static.aiHandle:=pv_reg_asyn('IOC_TEST:AI','pva');
  if(static.aiHandle < 0) {
    static.failCount +=1; 
    println('Failed reg IOC_TEST:AI, fail count:', static.failCount);
    # Test to register again
    static.aiHandle:=0;
  };
};

# Read value of "IOC_TEST:AI" when registered (auto updates via monitor)
if(static.aiHandle > 0) {
  if(pv_connected(static.aiHandle)) {
    # Value auto update by monitor.
    var retPvGet:=pv_value(static.aiHandle);    
    ${DBG=#}println('Get AI from PV YES!!!:', retPvGet);
  };
};


